

/*
struct BinaryActionPart {
	static void apply0(ExprState& state) {
		auto right = pop(state.stack.back());
		auto& dst = reinterpret_cast<ast::OpExpression&>(*state.stack.back().back());
		dst.children.emplace_back(std::move(right));
	}
};

template<> struct Action<AddPart> : BinaryActionPart {};
template<> struct Action<MultPart> : BinaryActionPart {};
*/

/*
struct OpExprState {
	std::vector<std::unique_ptr<ast::Expression>> exprs;
	ast::OpExpression::OpType op;
};
*/

/*
template<ast::OpExpression::OpType Op>
struct OpAction {
	static void apply0(ExprState& state) {
		auto left = pop(state.stack.back());
		auto expr = std::make_unique<ast::OpExpression>();
		expr->opType = Op;
		expr->children.emplace_back(std::move(left));
		state.stack.back().emplace_back(std::move(expr));
	}

	template<typename ParseInput>
	static void success(const ParseInput&, OpExprState& ns, ExprState& os) {
		auto expr = std::make_unique<ast::OpExpression>();
		expr->opType = ns.op;
		expr->children = std::move(ns.exprs);
		os.stack.push_back(std::move(expr));
	}
};
*/

// template<> struct Action<MultExpr> : OpAction {};
// template<> struct Action<AddExpr> : OpAction {};

/*
struct OpActionPart {
	static void apply0(ExprState& state) {
		auto left = pop(state.stack);
		auto expr = std::make_unique<ast::OpExpression>();
		expr->opType = Op;
		expr->children.emplace_back(std::move(left));
		state.stack.emplace_back(std::move(expr));
	}
};
*/

/*
template<> struct Action<Plus> : OpAction<ast::OpExpression::OpType::add> {};
template<> struct Action<Mult> : OpAction<ast::OpExpression::OpType::mult> {};
template<> struct Action<Divide> : OpAction<ast::OpExpression::OpType::div> {};
template<> struct Action<Minus> : OpAction<ast::OpExpression::OpType::sub> {};

template<> struct Action<NumberLiteral> {
	template<typename ParserInput>
	static void apply(ParserInput& in, ExprState& state) {
		auto expr = std::make_unique<ast::NumberLiteral>();
		// TODO: from_chars?
		std::stringstream ss(in.string());
		ss >> expr->number;
		state.stack.back().emplace_back(std::move(expr));
	}
};

template<> struct Action<IdentifierExpr> {
	template<typename ParserInput>
	static void apply(ParserInput& in, ExprState& state) {
		auto expr = std::make_unique<ast::IdentifierExpression>();
		expr->ident.name = in.string();
		state.stack.back().emplace_back(std::move(expr));
	}
};

template<> struct Action<CodeBlockBegin> {
	static void apply0(ExprState& state) {
		state.blocks.emplace_back();
	}
};

template<> struct Action<CodeBlock> {
	static void apply0(ExprState& state) {
		auto expr = std::make_unique<ast::CodeBlock>();
		expr->statements = pop(state.blocks);
		if(state.codeBlockReturn) {
			expr->ret = std::move(state.codeBlockReturn);
		}
		state.stack.back().emplace_back(std::move(expr));
	}
};

template<> struct Action<Assign> {
	static void apply0(ExprState& state) {
		auto assign = std::make_unique<ast::AssignStatement>();
		assign->right = pop(state.stack.back());
		assign->left = pop(state.stack.back());
		state.blocks.back().push_back(std::move(assign));
	}
};

template<> struct Action<CodeBlockReturn> {
	static void apply0(ExprState& state) {
		state.codeBlockReturn = pop(state.stack.back());
	}
};
*/

/*
struct Discard : pegtl::parse_tree::apply<Discard> {
      template< typename Node, typename... States >
      static void transform(std::unique_ptr< Node >& n, States&&...) {
		  n.reset();
	  }
};

struct Fold : pegtl::parse_tree::apply<Fold> {
      template< typename Node, typename... States >
      static void transform(std::unique_ptr< Node >& n, States&&...) {
		  if(n->children.size() == 1) {
			  n = std::move(n->children.front());
		  } else if(n->children.empty() && (!n->has_content() || n->string_view().empty())) {
			  n.reset();
		  }
	  }
};

struct DiscardChildren : pegtl::parse_tree::apply<DiscardChildren> {
      template< typename Node, typename... States >
      static void transform(std::unique_ptr< Node >& n, States&&...) {
		  n->children.clear();
	  }
};

template<typename Rule> struct selector : Fold {};
template<> struct selector<Identifier> : DiscardChildren {};
template<> struct selector<NumberLiteral> : DiscardChildren {};
template<> struct selector<Seps> : Discard {};

std::unique_ptr<ast::Expression> generateAST(const pegtl::parse_tree::node& node) {
	if(node.type == "Expr") {
		assert(node.children.size() == 1);
		return generateAST(*node.children[0]);
	}

	// TODO
}
*/

----

// TODO: separate expression and statement nests?
struct ExprStateLevel {
	std::vector<std::unique_ptr<ast::Statement>> stmts;
	std::vector<std::unique_ptr<ast::Expression>> exprs;
};

struct ExprState {
	std::vector<ExprStateLevel> stack;
};

template<typename T>
auto pop(T& container) {
	auto back = std::move(container.back());
	container.pop_back();
	return back;
}

// Control
template<typename Rule>
struct Control : pegtl::normal<Rule> {};

template<typename Rule>
struct PushPopControl : pegtl::normal<Rule> {
	template<typename ParseInput>
	static void start(const ParseInput&, ExprState& state) {
		std::cout << "push " << tao::demangle<Rule>() << ", " << state.stack.size() << "\n";
		state.stack.emplace_back();
	}

	template<typename ParseInput>
	static void failure(const ParseInput&, ExprState& state) {
		state.stack.pop_back();
		std::cout << "popf " << tao::demangle<Rule>() << ", " << state.stack.size() << "\n";
	}
};

template<> struct Control<Expr> : PushPopControl<Expr> {
	template<typename ParseInput>
	static void success(const ParseInput&, ExprState& state) {
		auto level = pop(state.stack);
		assert(level.exprs.size() == 1);
		assert(level.stmts.empty());
		state.stack.back().exprs.push_back(std::move(level.exprs[0]));
	}
};

template<> struct Control<Statement> : PushPopControl<Statement> {
	template<typename ParseInput>
	static void success(const ParseInput&, ExprState& state) {
		auto level = pop(state.stack);
		assert(level.stmts.size() == 1);
		assert(level.exprs.empty());
		state.stack.back().stmts.push_back(std::move(level.stmts[0]));
	}
};

template<typename Rule, ast::OpExpression::OpType Op>
struct OpExprPart : PushPopControl<Rule> {
	template<typename ParseInput>
	static void success(const ParseInput&, ExprState& state) {
		auto level = pop(state.stack);
		assert(level.exprs.size() == 1);

		auto& back = state.stack.back();
		assert(!level.exprs.empty());

		auto expr = std::make_unique<ast::OpExpression>();
		expr->opType = Op;
		expr->children.push_back(std::move(back.exprs.back())); // left
		expr->children.push_back(std::move(level.exprs[0])); // right
		back.exprs.back() = std::move(expr);
	}
};

template<> struct Control<AddPart> : OpExprPart<AddPart, ast::OpExpression::OpType::add> {};
template<> struct Control<MultPart> : OpExprPart<MultPart, ast::OpExpression::OpType::mult> {};
template<> struct Control<DivPart> : OpExprPart<DivPart, ast::OpExpression::OpType::div> {};
template<> struct Control<SubPart> : OpExprPart<SubPart, ast::OpExpression::OpType::sub> {};

/*
template<typename Rule>
struct OpExprControl : PushPopControl<Rule> {
	template<typename ParseInput>
	static void success(const ParseInput&, ExprState& state) {
		auto level = pop(state.stack);
		std::unique_ptr<ast::Expression> nexpr;

		assert(!level.exprs.empty());
		if(level.exprs.size() > 1) {
			auto expr = std::make_unique<ast::OpExpression>();
			expr->opType = level.op;
			expr->children = std::move(level.exprs);
			nexpr = std::move(expr);
			std::cout << "adding OpExpr" << "\n";
		} else {
			nexpr = std::move(level.exprs[0]);
			std::cout << "folding OpExpr" << "\n";
		}

		state.stack.back().exprs.push_back(std::move(nexpr));
		std::cout << "pop " << tao::demangle<Rule>() << ", " << state.stack.size() << "\n";
	}
};

template<> struct Control<MultExpr> : OpExprControl<MultExpr> {};
template<> struct Control<AddExpr> : OpExprControl<AddExpr> {};
*/

template<>
struct Control<CodeBlock> : PushPopControl<CodeBlock> {
	template<typename ParseInput>
	static void success(const ParseInput&, ExprState& state) {
		auto expr = std::make_unique<ast::CodeBlock>();
		auto level = pop(state.stack);

		expr->statements = std::move(level.stmts);

		// if there is an expression left over at the end of the
		// block, it's what we return
		// std::cout << level.exprs.size() << "\n";
		assert(level.exprs.size() <= 1);
		if(!level.exprs.empty()) {
			expr->ret = std::move(level.exprs[0]);
		}

		state.stack.back().exprs.push_back(std::move(expr));
	}
};

template<> struct Control<Assign> : PushPopControl<Assign> {
	template<typename ParserInput>
	static void success(ParserInput&, ExprState& state) {
		auto assign = std::make_unique<ast::AssignStatement>();
		auto level = pop(state.stack);

		assert(level.exprs.size() == 2);
		assign->left = std::move(level.exprs[0]);
		assign->right = std::move(level.exprs[1]);

		state.stack.back().stmts.push_back(std::move(assign));
	}
};

template<> struct Control<ExprStatement> : PushPopControl<ExprStatement> {
	template<typename ParserInput>
	static void success(ParserInput&, ExprState& state) {
		auto stmt = std::make_unique<ast::ExpressionStatement>();
		auto level = pop(state.stack);

		assert(level.exprs.size() == 1);
		stmt->expr = std::move(level.exprs[0]);

		std::cout << "success exprstatement " << state.stack.size() << "\n";
		state.stack.back().stmts.push_back(std::move(stmt));
	}
};

template<> struct Control<IfExpr> : PushPopControl<IfExpr> {
	template<typename ParserInput>
	static void success(ParserInput&, ExprState& state) {
		auto stmt = std::make_unique<ast::IfExprpression>();
		auto level = pop(state.stack);

		assert(level.exprs.size() == 1);
		stmt->expr = std::move(level.exprs[0]);

		std::cout << "success exprstatement " << state.stack.size() << "\n";
		state.stack.back().stmts.push_back(std::move(stmt));
	}
};

/*
template<typename Rule, ast::OpExpression::OpType Op>
struct OpControl : pegtl::normal<Rule> {
	template<typename ParserInput>
	static void success(ParserInput&, ExprState& state) {
		std::cout << "setting op\n";
		state.stack.back().op = Op;
	}
};

template<> struct Control<Plus> : OpControl<Plus, ast::OpExpression::OpType::add> {};
template<> struct Control<Mult> : OpControl<Mult, ast::OpExpression::OpType::mult> {};
template<> struct Control<Divide> : OpControl<Divide, ast::OpExpression::OpType::div> {};
template<> struct Control<Minus> : OpControl<Minus, ast::OpExpression::OpType::sub> {};
*/

// Action
template<typename Rule> struct Action : pegtl::nothing<Rule> {};

template<> struct Action<NumberLiteral> {
	template<typename ParserInput>
	static void apply(ParserInput& in, ExprState& state) {
		auto expr = std::make_unique<ast::NumberLiteral>();
		// TODO: from_chars?
		std::stringstream ss(in.string());
		ss >> expr->number;
		state.stack.back().exprs.emplace_back(std::move(expr));
	}
};

template<> struct Action<IdentifierExpr> {
	template<typename ParserInput>
	static void apply(ParserInput& in, ExprState& state) {
		auto expr = std::make_unique<ast::IdentifierExpression>();
		expr->ident.name = in.string();
		state.stack.back().exprs.emplace_back(std::move(expr));
	}
};

